<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Con Artist - Live Multiplayer</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React & ReactDOM CDNs -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap');
        body { font-family: 'Inter', sans-serif; overflow-x: hidden; }
        canvas { touch-action: none; cursor: crosshair; }
        .canvas-container { position: relative; width: 100%; max-width: 800px; aspect-ratio: 4/3; }
        .custom-scrollbar::-webkit-scrollbar { width: 4px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: transparent; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 10px; }
    </style>
</head>
<body class="bg-slate-100">
    <div id="root"></div>

    <script type="text/babel" data-presets="react" data-type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.1.0/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.1.0/firebase-auth.js";
        import { getFirestore, doc, setDoc, onSnapshot, updateDoc, getDoc, deleteDoc, collection } from "https://www.gstatic.com/firebasejs/11.1.0/firebase-firestore.js";

        const { useState, useEffect, useRef } = React;

        // --- CUSTOM SVG ICON COMPONENT ---
        const Icon = ({ name, size = 24, className = "" }) => {
            const icons = {
                Palette: <path d="M12 20a8 8 0 1 1 0-16 8 8 0 0 1 0 16zm-5-8a2 2 0 1 0 0-4 2 2 0 0 0 0 4zm10 0a2 2 0 1 0 0-4 2 2 0 0 0 0 4zm-5 4a2 2 0 1 0 0-4 2 2 0 0 0 0 4z" />,
                Users: <><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"/><circle cx="9" cy="7" r="4"/><path d="M22 21v-2a4 4 0 0 0-3-3.87"/><path d="M16 3.13a4 4 0 0 1 0 7.75"/></>,
                Vote: <><path d="m9 12 2 2 4-4"/><rect x="3" y="5" width="18" height="14" rx="2"/></>,
                Trophy: <><path d="M6 9H4.5a2.5 2.5 0 0 1 0-5H6"/><path d="M18 9h1.5a2.5 2.5 0 0 0 0-5H18"/><path d="M4 22h16"/><path d="M10 14.66V17c0 .55-.47.98-.97 1.21C7.85 18.75 7 20.24 7 22"/><path d="M17 22c0-1.76-.85-3.25-2.03-3.79-.5-.23-.97-.66-.97-1.21v-2.34"/><path d="M12 15a6 6 0 0 0 6-6V3H6v6a6 6 0 0 0 6 6Z"/></>,
                Play: <polygon points="5 3 19 12 5 21 5 3"/>,
                AlertCircle: <><circle cx="12" cy="12" r="10"/><line x1="12" y1="8" x2="12" y2="12"/><line x1="12" y1="16" x2="12.01" y2="16"/></>,
                RefreshCw: <><path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8"/><path d="M21 3v5h-5"/><path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16"/><path d="M3 21v-5h5"/></>,
                CheckCircle2: <><circle cx="12" cy="12" r="10"/><path d="m9 12 2 2 4-4"/></>,
                Brush: <><path d="m9.06 11.9 8.07-8.06a2.85 2.85 0 1 1 4.03 4.03l-8.06 8.08"/><path d="M7.07 14.94c-3.91.35-7.07 3.54-7.07 7.46a.6.6 0 0 0 .6.6h18.3c.33 0 .6-.27.6-.6 0-3.92-3.16-7.11-7.07-7.46"/><path d="m9 11 3 3"/></>,
                PaintBucket: <><path d="m19 11-8-8-7 7 8 8 7-7Z"/><path d="m5 10 7 7"/><path d="M7 13v5a2 2 0 0 0 2 2 2 2 0 0 1 2 2"/></>,
                Undo2: <><path d="M9 14 4 9l5-5"/><path d="M4 9h10.5a5.5 5.5 0 0 1 5.5 5.5v0a5.5 5.5 0 0 1-5.5 5.5H11"/></>,
                Check: <polyline points="20 6 9 17 4 12"/>,
                Pause: <><rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/></>,
                Clock: <><circle cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="2" /><polyline points="12 6 12 12 16 14" stroke="currentColor" strokeWidth="2" /></>
            };

            return (
                <svg
                    xmlns="http://www.w3.org/2000/svg"
                    width={size}
                    height={size}
                    viewBox="0 0 24 24"
                    fill="none"
                    stroke="currentColor"
                    strokeWidth="2"
                    strokeLinecap="round"
                    strokeLinejoin="round"
                    className={className}
                >
                    {icons[name] || null}
                </svg>
            );
        };

        // --- FIREBASE CONFIGURATION ---
        // REPLACE THESE VALUES WITH YOURS FROM THE FIREBASE CONSOLE
        const firebaseConfig = {
  apiKey: "AIzaSyAgBgs6ZpbLeSd5v-KT4w4DiIia9oGHN8Q",
  authDomain: "conartist-60c11.firebaseapp.com",
  projectId: "conartist-60c11",
  storageBucket: "conartist-60c11.firebasestorage.app",
  messagingSenderId: "28594153450",
  appId: "1:28594153450:web:40c1f697e132c43a113493",
  measurementId: "G-BG2HE0HEZ9"
        };

        const appId = 'my-con-artist-production-v1';

        const THEMES = ['Cat', 'Tree', 'House', 'Car', 'Sun', 'Flower', 'Bird', 'Fish', 'Pizza', 'Guitar', 'Book', 'Clock', 'Shoe', 'Hat', 'Cup', 'Star', 'Rocket', 'Mountain', 'Butterfly', 'Elephant', 'Cactus', 'Donut', 'Volcano', 'Bicycle', 'Taco', 'Submarine', 'Ghost', 'Alien', 'Robot', 'Pineapple', 'Smartphone', 'Ice Cream', 'Umbrella', 'Pizza Slice', 'Hamburger'];
        const PLAYER_COLORS = ['#E11D48', '#2563EB', '#059669', '#D97706', '#7C3AED', '#DB2777', '#0891B2', '#EA580C', '#4F46E5', '#16A34A'];

        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);

        // --- Flood Fill Algorithm ---
        const floodFill = (ctx, startX, startY, fillColor) => {
            const width = ctx.canvas.width;
            const height = ctx.canvas.height;
            const imageData = ctx.getImageData(0, 0, width, height);
            const data = imageData.data;
            const getPixel = (x, y) => {
                const i = (y * width + x) * 4;
                return [data[i], data[i+1], data[i+2], data[i+3]];
            };
            const targetColor = getPixel(startX, startY);
            const r = parseInt(fillColor.slice(1,3), 16), g = parseInt(fillColor.slice(3,5), 16), b = parseInt(fillColor.slice(5,7), 16);
            if (Math.abs(targetColor[0]-r) < 5 && Math.abs(targetColor[1]-g) < 5 && Math.abs(targetColor[2]-b) < 5) return;
            const stack = [[startX, startY]];
            while (stack.length > 0) {
                const [x, y] = stack.pop();
                if (x < 0 || x >= width || y < 0 || y >= height) continue;
                const i = (y * width + x) * 4;
                const current = getPixel(x, y);
                if (Math.abs(current[0]-targetColor[0]) < 20 && Math.abs(current[1]-targetColor[1]) < 20 && Math.abs(current[2]-targetColor[2]) < 20) {
                    data[i] = r; data[i+1] = g; data[i+2] = b; data[i+3] = 255;
                    stack.push([x-1, y], [x+1, y], [x, y-1], [x, y+1]);
                }
            }
            ctx.putImageData(imageData, 0, 0);
        };

        function App() {
            const [user, setUser] = useState(null);
            const [gameId, setGameId] = useState('');
            const [playerName, setPlayerName] = useState('');
            const [joinInput, setJoinInput] = useState('');
            const [gameState, setGameState] = useState(null);
            const [activeTool, setActiveTool] = useState('pen');
            const [isDrawing, setIsDrawing] = useState(false);
            const [currentStrokes, setCurrentStrokes] = useState([]);
            const [lastPoint, setLastPoint] = useState(null);
            const [errorMsg, setErrorMsg] = useState('');
            const canvasRef = useRef(null);
            const [timeLeft, setTimeLeft] = useState(30);

            useEffect(() => {
                signInAnonymously(auth).catch(e => setErrorMsg("Auth Error: Check Firebase Config"));
                return onAuthStateChanged(auth, setUser);
            }, []);

            useEffect(() => {
                if (!gameState || gameState.phase !== 'drawing') return;
                const interval = setInterval(() => {
                    if (gameState.turnExpiresAt) {
                        const remaining = Math.max(0, Math.ceil((gameState.turnExpiresAt - Date.now()) / 1000));
                        setTimeLeft(remaining);

                        if (remaining === 0 && gameState.currentDrawer === user?.uid) {
                            finishTurn();
                        }
                        if ((gameState.turnExpiresAt - Date.now()) < -5000 && gameState.hostId === user?.uid) {
                             finishTurn();
                        }
                    }
                }, 1000);
                return () => clearInterval(interval);
            }, [gameState, user]);

            useEffect(() => {
                if (!user || !gameId) return;
                const gameRef = doc(db, 'games', gameId);
                return onSnapshot(gameRef, (snap) => {
                    if (snap.exists()) {
                        const data = snap.data();
                        setGameState(data);
                        if (data.phase !== 'lobby') requestAnimationFrame(() => drawHistory(data.history || []));
                    } else { setGameId(''); setGameState(null); }
                });
            }, [user, gameId]);

            const drawHistory = (history) => {
                const canvas = canvasRef.current;
                if (!canvas) return;
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                history.forEach(action => {
                    if (action.type === 'stroke') {
                        ctx.strokeStyle = action.color; ctx.lineWidth = 4; ctx.lineCap = 'round'; ctx.lineJoin = 'round';
                        ctx.beginPath(); ctx.moveTo(action.x1, action.y1); ctx.lineTo(action.x2, action.y2); ctx.stroke();
                    } else if (action.type === 'fill') {
                        floodFill(ctx, action.x, action.y, action.color);
                    }
                });
            };

            const createGame = async () => {
                if (!user || !playerName.trim()) { setErrorMsg("Enter your name first!"); return; }
                const code = Math.random().toString(36).substring(2, 6).toUpperCase().replace(/[0-9]/g, 'A');
                const gameData = {
                    id: code, hostId: user.uid, players: [{ id: user.uid, name: playerName, color: PLAYER_COLORS[0], score: 0, voted: false }],
                    phase: 'lobby', history: [], theme: '', conId: '', currentDrawer: '', drawerIndex: 0, round: 1, isPaused: false
                };
                try {
                    await setDoc(doc(db, 'games', code), gameData);
                    setGameId(code);
                } catch (e) { setErrorMsg("Database Rules Denied. Check Firestore rules."); }
            };

            const joinGame = async () => {
                if (!user || !playerName.trim()) { setErrorMsg("Enter your name first!"); return; }
                const code = joinInput.toUpperCase();
                try {
                    const snap = await getDoc(doc(db, 'games', code));
                    if (snap.exists()) {
                        const data = snap.data();
                        if (!data.players.find(p => p.id === user.uid)) {
                            const newPlayers = [...data.players, { id: user.uid, name: playerName, color: PLAYER_COLORS[data.players.length % 10], score: 0, voted: false }];
                            await updateDoc(doc(db, 'games', code), { players: newPlayers });
                        }
                        setGameId(code);
                    } else setErrorMsg("Room not found!");
                } catch (e) { setErrorMsg("Join Error."); }
            };

            const startGame = async () => {
                const theme = THEMES[Math.floor(Math.random() * THEMES.length)];
                const conId = gameState.players[Math.floor(Math.random() * gameState.players.length)].id;
                await updateDoc(doc(db, 'games', gameId), {
                    phase: 'drawing', theme, conId, currentDrawer: gameState.players[0].id, drawerIndex: 0, round: 1, history: [], isPaused: false, turnExpiresAt: Date.now() + 30000
                });
            };

            const finishTurn = async () => {
                const nextIdx = (gameState.drawerIndex + 1) % gameState.players.length;
                const nextRound = nextIdx === 0 ? gameState.round + 1 : gameState.round;
                const updates = { history: [...gameState.history, ...currentStrokes], drawerIndex: nextIdx, currentDrawer: gameState.players[nextIdx].id, round: nextRound, turnExpiresAt: Date.now() + 30000 };
                if (nextRound > 2) { updates.phase = 'voting'; updates.currentDrawer = ''; }
                await updateDoc(doc(db, 'games', gameId), updates);
                setCurrentStrokes([]);
            };

            const handleVote = async (tid) => {
                const ups = gameState.players.map(p => p.id === user.uid ? { ...p, voted: true, vote: tid } : p);
                const all = ups.every(p => p.voted);
                const updates = { players: ups };
                if (all) {
                    updates.phase = 'results';
                    const vts = {}; ups.forEach(p => vts[p.vote] = (vts[p.vote] || 0) + 1);
                    let mv = 0, aid = null;
                    Object.entries(vts).forEach(([id, c]) => { if (c > mv) { mv = c; aid = id; } });
                    const caught = aid === gameState.conId;
                    updates.players = ups.map(p => ({ ...p, score: p.score + (caught ? (p.id !== gameState.conId ? 1 : 0) : (p.id === gameState.conId ? 2 : 0)), voted: false, vote: null }));
                    updates.lastResult = caught ? "CAUGHT" : "ESCAPED";
                }
                await updateDoc(doc(db, 'games', gameId), updates);
            };

            const getPos = (e) => {
                const rect = canvasRef.current.getBoundingClientRect();
                return {
                    x: ((e.touches ? e.touches[0].clientX : e.clientX) - rect.left) * (800 / rect.width),
                    y: ((e.touches ? e.touches[0].clientY : e.clientY) - rect.top) * (600 / rect.height)
                };
            };

            if (!gameState) return (
                <div className="min-h-screen bg-slate-900 flex items-center justify-center p-6 text-white">
                    <div className="bg-slate-800 p-8 rounded-3xl shadow-2xl w-full max-w-md border border-slate-700">
                        <div className="flex flex-col items-center mb-8">
                            <div className="bg-rose-500 p-4 rounded-2xl mb-4 shadow-lg"><Icon name="Palette" size={48} /></div>
                            <h1 className="text-4xl font-black tracking-tighter uppercase">Con Artist</h1>
                            <p className="text-slate-400 font-bold mt-2">Deduce or Deceive</p>
                        </div>
                        <input className="w-full bg-slate-700 p-4 rounded-xl mb-4 text-white outline-none focus:ring-2 ring-rose-500" placeholder="Your Name" value={playerName} onChange={e => setPlayerName(e.target.value)} />
                        <button onClick={createGame} className="w-full bg-rose-500 p-4 rounded-xl font-bold mb-4 hover:bg-rose-600 active:scale-95 transition-all">CREATE ROOM</button>
                        <div className="flex gap-2">
                            <input className="flex-grow bg-slate-700 p-4 rounded-xl font-mono uppercase text-white outline-none focus:ring-2 ring-cyan-500" placeholder="CODE" maxLength={4} value={joinInput} onChange={e => setJoinInput(e.target.value)} />
                            <button onClick={joinGame} className="bg-cyan-500 px-8 rounded-xl font-bold hover:bg-cyan-600 active:scale-95 transition-all">JOIN</button>
                        </div>
                        {errorMsg && <p className="text-rose-400 mt-4 text-center font-bold">{errorMsg}</p>}
                    </div>
                </div>
            );

            const myTurn = gameState.currentDrawer === user?.uid;
            return (
                <div className="min-h-screen bg-slate-100 flex flex-col md:flex-row">
                    <div className="w-full md:w-80 bg-white border-r p-6 flex flex-col shadow-sm">
                        <div className="flex items-center justify-between mb-8">
                            <h2 className="text-2xl font-black text-slate-800">Lobby</h2>
                            <span className="bg-slate-800 text-white px-3 py-1 rounded-lg font-mono text-sm shadow-inner">{gameState.id}</span>
                        </div>
                        <div className="flex-grow space-y-4 overflow-y-auto custom-scrollbar">
                            {gameState.players.map(p => (
                                <div key={p.id} className={`flex items-center gap-3 p-3 rounded-xl border-2 transition-all ${gameState.currentDrawer === p.id ? 'border-rose-500 bg-rose-50' : 'border-slate-100'}`}>
                                    <div className="w-8 h-8 rounded-full shadow-sm" style={{backgroundColor: p.color}} />
                                    <span className="font-bold text-slate-700 truncate max-w-[150px]">{p.name} {p.id === user?.uid && "(You)"}</span>
                                    {p.voted && <Icon name="CheckCircle2" size={16} className="ml-auto text-emerald-500" />}
                                </div>
                            ))}
                        </div>
                        {gameState.phase === 'lobby' && gameState.hostId === user?.uid && (
                            <button onClick={startGame} className="bg-emerald-500 text-white p-4 rounded-xl font-bold mt-4 flex items-center justify-center gap-2 hover:bg-emerald-600 transition-colors shadow-md">
                                <Icon name="Play" size={20}/> START GAME
                            </button>
                        )}
                    </div>
                    <div className="flex-grow p-4 md:p-8 flex flex-col items-center">
                        <div className="w-full max-w-[800px] bg-white p-6 rounded-2xl shadow-sm mb-6 flex justify-between items-center border border-slate-200">
                            <div><p className="text-xs font-bold text-slate-400 uppercase tracking-widest">Theme</p><h3 className="text-3xl font-black text-slate-800">{gameState.phase === 'drawing' ? (gameState.conId === user?.uid ? "ðŸŽ­ ???" : gameState.theme) : "Voting Time"}</h3></div>
                            <div className="flex flex-col items-end">
                                <div className="text-right mb-2"><p className="text-xs font-bold text-slate-400 uppercase tracking-widest">Round</p><span className="text-2xl font-black text-rose-500 font-mono">{gameState.round}/2</span></div>
                                {gameState.phase === 'drawing' && (
                                    <div className="flex items-center gap-2 bg-slate-100 px-3 py-1 rounded-lg">
                                        <Icon name="Clock" size={16} className="text-slate-500" />
                                        <span className={`font-mono font-bold text-xl ${timeLeft < 10 ? 'text-rose-500 animate-pulse' : 'text-slate-700'}`}>{timeLeft}s</span>
                                    </div>
                                )}
                            </div>
                        </div>
                        <div className="canvas-container bg-white rounded-3xl shadow-xl relative border-8 border-slate-200 overflow-hidden">
                            <canvas ref={canvasRef} width={800} height={600} className="w-full bg-white"
                                onMouseDown={(e) => {
                                    if (gameState.currentDrawer !== user?.uid) return;
                                    setIsDrawing(true); setLastPoint(getPos(e));
                                    if(activeTool === 'fill') {
                                        const x = Math.floor(getPos(e).x);
                                        const y = Math.floor(getPos(e).y);
                                        const color = gameState.players.find(p => p.id === user.uid).color;
                                        floodFill(canvasRef.current.getContext('2d'), x, y, color);
                                        setCurrentStrokes(p => [...p, { type: 'fill', x, y, color }]);
                                    }
                                }}
                                onMouseMove={(e) => {
                                    if (!isDrawing || activeTool === 'fill') return;
                                    const pos = getPos(e); const ctx = canvasRef.current.getContext('2d');
                                    ctx.strokeStyle = gameState.players.find(p => p.id === user.uid).color; ctx.lineWidth = 4; ctx.lineCap = 'round';
                                    ctx.beginPath(); ctx.moveTo(lastPoint.x, lastPoint.y); ctx.lineTo(pos.x, pos.y); ctx.stroke();
                                    setCurrentStrokes(p => [...p, { type: 'stroke', x1: lastPoint.x, y1: lastPoint.y, x2: pos.x, y2: pos.y, color: ctx.strokeStyle }]);
                                    setLastPoint(pos);
                                }}
                                onMouseUp={() => setIsDrawing(false)}
                                onTouchStart={(e) => {
                                    if (gameState.currentDrawer !== user?.uid) return;
                                    setIsDrawing(true); setLastPoint(getPos(e));
                                    if(activeTool === 'fill') {
                                        const x = Math.floor(getPos(e).x);
                                        const y = Math.floor(getPos(e).y);
                                        const color = gameState.players.find(p => p.id === user.uid).color;
                                        floodFill(canvasRef.current.getContext('2d'), x, y, color);
                                        setCurrentStrokes(p => [...p, { type: 'fill', x, y, color }]);
                                    }
                                }}
                                onTouchMove={(e) => {
                                    if (!isDrawing || activeTool === 'fill') return;
                                    const pos = getPos(e); const ctx = canvasRef.current.getContext('2d');
                                    ctx.strokeStyle = gameState.players.find(p => p.id === user.uid).color; ctx.lineWidth = 4; ctx.lineCap = 'round';
                                    ctx.beginPath(); ctx.moveTo(lastPoint.x, lastPoint.y); ctx.lineTo(pos.x, pos.y); ctx.stroke();
                                    setCurrentStrokes(p => [...p, { type: 'stroke', x1: lastPoint.x, y1: lastPoint.y, x2: pos.x, y2: pos.y, color: ctx.strokeStyle }]);
                                    setLastPoint(pos);
                                }}
                                onTouchEnd={() => setIsDrawing(false)}
                            />
                            {gameState.phase === 'voting' && (
                                <div className="absolute inset-0 bg-slate-900/80 backdrop-blur-md flex flex-col items-center justify-center p-8 text-white z-10">
                                    <Icon name="Vote" size={64} className="mb-4 text-cyan-400 animate-bounce" />
                                    <h2 className="text-4xl font-black mb-8 text-center uppercase tracking-tighter">Who is the Con Artist?</h2>
                                    <div className="grid grid-cols-2 gap-4 w-full max-w-md">
                                        {gameState.players.map(p => p.id !== user?.uid && (
                                            <button key={p.id} onClick={() => handleVote(p.id)} className="bg-white/10 p-6 rounded-2xl border-2 border-white/20 font-bold hover:bg-white/20 transition-all text-lg">{p.name}</button>
                                        ))}
                                    </div>
                                </div>
                            )}
                            {gameState.phase === 'results' && (
                                <div className="absolute inset-0 bg-slate-900/90 flex flex-col items-center justify-center text-white p-8 z-20 text-center">
                                    <Icon name="Trophy" size={80} className="mb-6 text-yellow-500" />
                                    <h2 className="text-5xl font-black mb-4 tracking-tighter uppercase">The Con {gameState.lastResult}!</h2>
                                    <p className="text-2xl font-bold bg-white/10 px-6 py-2 rounded-full border border-white/20">Identity: {gameState.players.find(p => p.id === gameState.conId)?.name}</p>
                                    {gameState.hostId === user?.uid && (
                                        <button onClick={startGame} className="mt-12 bg-white text-slate-900 px-12 py-5 rounded-2xl font-black text-xl hover:bg-slate-100 active:scale-95 transition-all">NEXT ROUND</button>
                                    )}
                                </div>
                            )}
                        </div>
                        {myTurn && gameState.phase === 'drawing' && (
                            <div className="w-full max-w-[800px] mt-6 flex flex-wrap gap-4 justify-center bg-slate-900 p-4 rounded-3xl shadow-2xl z-30">
                                <button onClick={() => setActiveTool('pen')} className={`p-4 rounded-2xl transition-all ${activeTool === 'pen' ? 'bg-rose-500 text-white shadow-lg shadow-rose-500/40' : 'bg-slate-700 text-slate-400 hover:text-white'}`}>
                                    <Icon name="Brush" size={24}/>
                                </button>
                                <button onClick={() => setActiveTool('fill')} className={`p-4 rounded-2xl transition-all ${activeTool === 'fill' ? 'bg-rose-500 text-white shadow-lg shadow-rose-500/40' : 'bg-slate-700 text-slate-400 hover:text-white'}`}>
                                    <Icon name="PaintBucket" size={24}/>
                                </button>
                                <button onClick={() => {
                                    const nextStrokes = [...currentStrokes];
                                    nextStrokes.pop();
                                    setCurrentStrokes(nextStrokes);
                                    requestAnimationFrame(() => drawHistory([...gameState.history, ...nextStrokes]));
                                }} className="p-4 rounded-2xl bg-slate-700 text-slate-400 hover:text-white transition-all">
                                    <Icon name="Undo2" size={24}/>
                                </button>
                                <div className="w-px bg-slate-700 mx-2" />
                                <button onClick={finishTurn} className="bg-emerald-500 text-white px-10 rounded-2xl font-black text-lg hover:bg-emerald-600 transition-all active:scale-95 flex items-center gap-2">
                                    <Icon name="Check" size={24}/> DONE!
                                </button>
                            </div>
                        )}
                        {!myTurn && gameState.phase === 'drawing' && (
                            <div className="mt-8 bg-slate-800 text-white px-8 py-4 rounded-full flex items-center gap-4 shadow-xl border border-slate-700">
                                <Icon name="RefreshCw" size={20} className="animate-spin text-cyan-400" />
                                <span className="font-bold">{gameState.players.find(p => p.id === gameState.currentDrawer)?.name} is sketching...</span>
                            </div>
                        )}
                    </div>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>